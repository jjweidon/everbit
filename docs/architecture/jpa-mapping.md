# JPA 엔티티 매핑 표준

Status: **Ready for Implementation (v2 MVP)**  
Owner: everbit  
Last updated: 2026-02-17 (Asia/Seoul)

이 문서는 `docs/architecture/data-model.md`와 `docs/db/schema-v2-mvp.sql`에 고정된 스키마를 **Spring Data JPA(Hibernate)** 로 구현할 때,
복합키(Composite Key)와 공유 PK(Shared Primary Key)를 안전하게 매핑하는 표준 패턴을 정의한다.

핵심 원칙:
- 정합성/멱등성은 **DB 제약(UNIQUE/PK/CHECK)** 이 최종 기준(SoT)이다.
- JPA는 저장/조회 편의 계층이다. DB에 이미 존재하는 제약을 코드로 “대체”하지 않는다.
- 키 전략은 v2 MVP 기준으로 다음을 사용한다.
  - 내부 조인/성능 기준 PK: `bigint identity` → JPA `Long`
  - 외부 노출/추적용: `public_id(ULID)` → JPA `String`
  - 외부 시스템/이벤트 식별: `uuid` → JPA `java.util.UUID`

---

## 1. 적용 범위/전제

- Spring Boot 3.x + Hibernate 6.x 기준 예시를 제공한다.
  - Hibernate 5.x/구버전에서는 JSON 매핑 방식이 달라질 수 있다.
- 테이블/컬럼 네이밍은 DDL의 snake_case를 그대로 사용한다.
- 단방향 연관관계를 기본으로 하되, 필요할 때만 양방향을 허용한다.

---

## 2. 테이블별 키/매핑 전략 요약

| 테이블 | DB 키 전략 | JPA ID 타입 | 매핑 패턴 |
|---|---:|---|---|
| `app_user` | `id bigint identity` | `Long` | 단일 PK + `public_id(ULID)` |
| `upbit_key` | `owner_id bigint PK = FK(app_user.id)` | `Long` | **공유 PK**: `@MapsId` |
| `kill_switch` | `owner_id bigint PK = FK(app_user.id)` | `Long` | **공유 PK**: `@MapsId` |
| `strategy_config` | `(owner_id, strategy_key)` 복합 PK | `StrategyConfigId` | **복합키**: `@EmbeddedId` + `@MapsId(ownerId)` |
| `market_config` | `(owner_id, market)` 복합 PK | `MarketConfigId` | **복합키**: `@EmbeddedId` + `@MapsId(ownerId)` |
| `position` | `(owner_id, market)` 복합 PK | `PositionId` | **복합키**: `@EmbeddedId` + `@MapsId(ownerId)` |
| `backtest_result` | `job_id bigint PK = FK(backtest_job.id)` | `Long` | **공유 PK**: `@MapsId` |

> 나머지(예: `signal`, `order_intent`, `order_attempt`, `outbox_event`)는 surrogate PK(Long)를 쓰고,
> 멱등/중복 방지용 UNIQUE 제약은 DB에 유지한다.

---

## 3. 공통 매핑 규칙

### 3.1 `bigint identity` ↔ JPA `Long`

DDL이 `GENERATED BY DEFAULT AS IDENTITY` 이므로 엔티티에서는 아래를 표준으로 한다.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;
```

주의:
- `IDENTITY`는 **insert 시점에만 id가 확정**된다(대부분 flush 이후). 따라서 **부모 id가 필요한 자식(복합키/공유PK)** 을 같은 트랜잭션에서 동시에 만들려면,
  - (권장) 부모를 먼저 저장/flush 후 자식을 생성하거나
  - 애초에 “부모(OWNER)는 선행 생성”이라는 도메인 규칙을 지킨다(everbit는 로그인 시 owner가 선행 생성).

### 3.2 `public_id(ULID)`

- `public_id`는 DB 생성이 아니라 **애플리케이션에서 생성**한다.
- 표준 매핑:

```java
@Column(name = "public_id", nullable = false, unique = true, length = 26, columnDefinition = "char(26)")
private String publicId;
```

운영 규칙:
- 저장 전 **반드시 26자 ULID**를 세팅한다(서비스/팩토리 레이어에서 생성).
- 동일 밀리초 다량 생성 가능성이 있으면 **monotonic ULID 생성기**를 사용한다(충돌/정렬 안정성 목적).

### 3.3 `uuid` 컬럼

- PostgreSQL `uuid` ↔ Java `java.util.UUID` 를 사용한다.

```java
@Column(name = "upbit_uuid", columnDefinition = "uuid")
private UUID upbitUuid;
```

### 3.4 JSONB

- `jsonb`는 v2 MVP에서 스키마 유연성이 필요하므로 유지한다.
- 표준(예: Jackson `JsonNode` 사용, Hibernate 6 기준):

```java
@JdbcTypeCode(SqlTypes.JSON)
@Column(name = "config_json", columnDefinition = "jsonb", nullable = false)
private JsonNode configJson;
```

### 3.5 연관관계 기본값

- `@ManyToOne`은 `fetch = LAZY`를 기본으로 한다.
- `@OneToOne(fetch = LAZY)`는 Hibernate 설정/바이트코드 향상 여부에 따라 **사실상 EAGER로 동작**할 수 있다.
  - 성능 이슈가 생기면 `@ManyToOne` + DB의 **PK/UNIQUE로 1:1을 강제**하는 방식으로 전환한다.

---

## 4. 복합키(Composite Key) 표준: `@Embeddable` + `@EmbeddedId`

### 4.1 언제 복합키를 쓰는가

v2 MVP 기준 복합키는 아래 조건에서만 허용한다.
- 자연키가 명확하고(예: owner + market),
- 해당 테이블이 다른 테이블에서 광범위하게 참조되지 않으며,
- 키 변경이 비즈니스적으로 “데이터 재생성”에 가까운 경우

적용 테이블:
- `strategy_config (owner_id, strategy_key)`
- `market_config (owner_id, market)`
- `position (owner_id, market)`

### 4.2 `@Embeddable` ID 클래스 규칙

- `implements Serializable` 필수
- 필드는 **원시 타입/값 타입만**(연관관계 금지)
- `equals/hashCode`는 **키 필드 전부**로 구성
- 키는 불변에 가깝게 다룬다(생성 후 변경 금지)

#### 예시: `StrategyConfigId`

```java
@Embeddable
public class StrategyConfigId implements Serializable {

  @Column(name = "owner_id", nullable = false)
  private Long ownerId;

  @Column(name = "strategy_key", nullable = false, length = 64)
  private String strategyKey;

  protected StrategyConfigId() {}

  public StrategyConfigId(Long ownerId, String strategyKey) {
    this.ownerId = ownerId;
    this.strategyKey = strategyKey;
  }

  // equals/hashCode: ownerId + strategyKey
}
```

### 4.3 엔티티 매핑: `@EmbeddedId` + `@MapsId`

복합키에 FK(`owner_id`)가 포함되는 경우, 아래 표준을 따른다.
- 엔티티에 `AppUser owner` 연관관계를 둔다.
- `@MapsId("ownerId")`로 **ID의 ownerId와 FK 컬럼을 하나로 결합**한다.
  - 이 패턴을 쓰면 `insertable=false/updatable=false` 같은 우회 설정이 필요 없다.

#### 예시: `strategy_config`

```java
@Entity
@Table(name = "strategy_config")
public class StrategyConfig {

  @EmbeddedId
  private StrategyConfigId id;

  @MapsId("ownerId")
  @ManyToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "owner_id", nullable = false)
  private AppUser owner;

  @Column(name = "config_version", nullable = false)
  private int configVersion;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "config_json", columnDefinition = "jsonb", nullable = false)
  private JsonNode configJson;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected StrategyConfig() {}

  public StrategyConfig(AppUser owner, String strategyKey, int configVersion, JsonNode configJson) {
    // owner는 선행 생성되어 id를 보유해야 한다(IDENTITY 전략 주의)
    this.owner = owner;
    this.id = new StrategyConfigId(owner.getId(), strategyKey);
    this.configVersion = configVersion;
    this.configJson = configJson;
    this.updatedAt = Instant.now();
  }

  @PreUpdate
  void touch() {
    this.updatedAt = Instant.now();
  }
}
```

#### Repository 예시

```java
public interface StrategyConfigRepository extends JpaRepository<StrategyConfig, StrategyConfigId> {
  Optional<StrategyConfig> findByIdOwnerIdAndIdStrategyKey(Long ownerId, String strategyKey);
}
```

### 4.4 `market_config`, `position` 적용

동일한 패턴을 사용한다.
- `MarketConfigId(ownerId, market)`
- `PositionId(ownerId, market)`

주의:
- 키 컬럼(예: market)을 바꾸는 UPDATE는 금지한다.
  - 변경은 **삭제 + 신규 생성** 또는 신규 row 생성으로 처리한다.

---

## 5. 공유 PK(Shared Primary Key) 표준: `@MapsId`

### 5.1 언제 공유 PK를 쓰는가

DB에서 “정확히 1개만 존재해야 하는 하위 테이블”에 적용한다.
- `upbit_key`: owner 당 1세트
- `kill_switch`: owner 당 1개
- `backtest_result`: job 당 1개

### 5.2 표준 패턴(A안): `@Id` + `@MapsId`

표준은 아래 형태로 고정한다.

```java
@Id
@Column(name = "owner_id")
private Long ownerId;

@MapsId
@OneToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "owner_id")
private AppUser owner;
```

이 패턴의 장점:
- PK와 FK가 완전히 동일하게 동작한다.
- ownerId를 별도로 세팅하지 않아도 owner를 세팅하면 id가 일치한다.

### 5.3 예시: `upbit_key`

```java
@Entity
@Table(name = "upbit_key")
public class UpbitKey {

  @Id
  @Column(name = "owner_id")
  private Long ownerId;

  @MapsId
  @OneToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "owner_id")
  private AppUser owner;

  @Column(name = "access_key_enc", nullable = false)
  private byte[] accessKeyEnc;

  @Column(name = "secret_key_enc", nullable = false)
  private byte[] secretKeyEnc;

  @Column(name = "key_version", nullable = false)
  private int keyVersion;

  @Column(name = "created_at", nullable = false)
  private Instant createdAt;

  @Column(name = "rotated_at")
  private Instant rotatedAt;

  protected UpbitKey() {}

  public UpbitKey(AppUser owner, byte[] accessKeyEnc, byte[] secretKeyEnc, int keyVersion) {
    // owner는 선행 생성되어 id를 보유해야 한다(IDENTITY 전략 주의)
    this.owner = owner;
    this.accessKeyEnc = accessKeyEnc;
    this.secretKeyEnc = secretKeyEnc;
    this.keyVersion = keyVersion;
    this.createdAt = Instant.now();
  }
}
```

보안 주의:
- 민감정보(`*_enc`)는 `toString()`/로그/JSON 응답에 절대 포함하지 않는다.
  - Lombok 사용 시 `@ToString(exclude = ...)`, DTO 분리 강제.

### 5.4 예시: `kill_switch`

```java
@Entity
@Table(name = "kill_switch")
public class KillSwitch {

  @Id
  @Column(name = "owner_id")
  private Long ownerId;

  @MapsId
  @OneToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "owner_id")
  private AppUser owner;

  @Column(name = "account_enabled", nullable = false)
  private boolean accountEnabled;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "enabled_strategies", columnDefinition = "jsonb", nullable = false)
  private JsonNode enabledStrategies;

  @Column(name = "updated_at", nullable = false)
  private Instant updatedAt;

  protected KillSwitch() {}
}
```

### 5.5 예시: `backtest_result` (job_id 공유 PK)

```java
@Entity
@Table(name = "backtest_result")
public class BacktestResult {

  @Id
  @Column(name = "job_id")
  private Long jobId;

  @MapsId
  @OneToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "job_id")
  private BacktestJob job;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "metrics_json", columnDefinition = "jsonb", nullable = false)
  private JsonNode metricsJson;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "equity_curve_json", columnDefinition = "jsonb")
  private JsonNode equityCurveJson;

  @Column(name = "created_at", nullable = false)
  private Instant createdAt;

  protected BacktestResult() {}
}
```

### 5.6 공유 PK 생성 순서(강제)

공유 PK는 “부모 PK 값”이 곧 자식 PK 값이므로, 아래 순서를 지킨다.
1) 부모를 먼저 저장해서 PK를 확보한다.
2) 자식을 생성/저장한다.

everbit v2 MVP에서는 `app_user`가 로그인 시점에 선행 생성되므로,
`upbit_key`/`kill_switch`는 owner의 id가 이미 존재한다는 전제를 둔다.

---

## 6. 운영 체크리스트

- [ ] 복합키/공유 PK 엔티티에서 **키 필드 변경 UPDATE 금지**(키 변경은 신규 생성으로 처리)
- [ ] `@EmbeddedId` 클래스에 `equals/hashCode` 구현 완료
- [ ] `@MapsId`를 사용해 FK/ID 컬럼 **중복 매핑 제거**
- [ ] `@OneToOne(fetch = LAZY)`가 실제로 EAGER가 되는지 프로파일링(필요 시 `@ManyToOne` 대체)
- [ ] 민감정보 컬럼(`*_enc`) 로깅/직렬화 차단
- [ ] DB CHECK/UNIQUE 제약을 테스트에서 검증(통합 테스트로 실패 케이스 포함)

